// CandidateSelectorForm.cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Windows.Forms;

namespace CTSegmenter
{
    /// <summary>
    /// Form that displays up to 4 candidate masks for each (direction, material) pair
    /// and lets the user select which candidate (if any) to adopt for that material.
    /// </summary>
    public class CandidateSelectorForm : Form
    {
        private TabControl tabControl;
        private Button btnOK;
        private Button btnCancel;
        private Button btnPreview;
        private Button btnSaveComposite;
        private SAMForm _parentForm; // Reference to parent form for preview

        // For each direction: dictionary (materialName → selected candidate index).
        public Dictionary<string, Dictionary<string, int>> Selections { get; private set; }

        // For each direction: dictionary (materialName → list of candidate bitmaps).
        private Dictionary<string, Dictionary<string, List<Bitmap>>> _allCandidates;

        // For each direction: dictionary (materialName → the final chosen mask).
        public Dictionary<string, Dictionary<string, Bitmap>> SelectedMasks { get; private set; }

        // Distinct material colors if needed for composite
        private static readonly Color[] MaterialColors = new Color[] {
            Color.Red, Color.Green, Color.Blue, Color.Yellow, Color.Magenta,
            Color.Cyan, Color.Orange, Color.Purple, Color.Lime, Color.Teal,
            Color.Pink, Color.Brown, Color.Navy, Color.Maroon, Color.Olive
        };

        public CandidateSelectorForm(
            Dictionary<string, Dictionary<string, List<Bitmap>>> allCandidates,
            SAMForm parentForm = null)
        {
            _allCandidates = allCandidates;
            _parentForm = parentForm;
            Selections = new Dictionary<string, Dictionary<string, int>>();
            SelectedMasks = new Dictionary<string, Dictionary<string, Bitmap>>();

            InitializeComponent();
            PopulateTabs();
        }

        private void InitializeComponent()
        {
            this.Text = "Select Candidate Masks";
            this.Size = new Size(1100, 800);
            this.StartPosition = FormStartPosition.CenterParent;
            this.FormBorderStyle = FormBorderStyle.Sizable;
            this.MinimumSize = new Size(800, 600);

            tabControl = new TabControl();
            tabControl.Dock = DockStyle.Fill;
            tabControl.Padding = new Point(10, 10);
            this.Controls.Add(tabControl);

            // Create button panel
            Panel buttonPanel = new Panel();
            buttonPanel.Dock = DockStyle.Bottom;
            buttonPanel.Height = 50;
            buttonPanel.Padding = new Padding(10);

            // Preview
            btnPreview = new Button();
            btnPreview.Text = "Preview in Main View";
            btnPreview.Width = 150;
            btnPreview.Anchor = AnchorStyles.Bottom | AnchorStyles.Left;
            btnPreview.Location = new Point(15, 15);
            btnPreview.Click += BtnPreview_Click;

            // Save composite
            btnSaveComposite = new Button();
            btnSaveComposite.Text = "Save Composite Image";
            btnSaveComposite.Width = 150;
            btnSaveComposite.Anchor = AnchorStyles.Bottom | AnchorStyles.Left;
            btnSaveComposite.Location = new Point(175, 15);
            btnSaveComposite.Click += BtnSaveComposite_Click;

            // OK
            btnOK = new Button();
            btnOK.Text = "OK";
            btnOK.DialogResult = DialogResult.OK;
            btnOK.Width = 80;
            btnOK.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
            btnOK.Location = new Point(buttonPanel.Width - 180, 15);
            btnOK.Click += BtnOK_Click;

            // Cancel
            btnCancel = new Button();
            btnCancel.Text = "Cancel";
            btnCancel.DialogResult = DialogResult.Cancel;
            btnCancel.Width = 80;
            btnCancel.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
            btnCancel.Location = new Point(buttonPanel.Width - 90, 15);

            buttonPanel.Controls.Add(btnPreview);
            buttonPanel.Controls.Add(btnSaveComposite);
            buttonPanel.Controls.Add(btnOK);
            buttonPanel.Controls.Add(btnCancel);

            this.Controls.Add(buttonPanel);
        }

        private void PopulateTabs()
        {
            // We have directions like "XY", "XZ", "YZ"
            foreach (string direction in new string[] { "XY", "XZ", "YZ" })
            {
                TabPage tab = new TabPage(direction);
                Selections[direction] = new Dictionary<string, int>();
                SelectedMasks[direction] = new Dictionary<string, Bitmap>();

                if (!_allCandidates.ContainsKey(direction))
                {
                    tabControl.TabPages.Add(tab);
                    continue;
                }

                var materials = _allCandidates[direction].Keys.ToList();

                // We'll stack materials vertically
                // Each row: material label + candidate images
                TableLayoutPanel mainPanel = new TableLayoutPanel();
                mainPanel.Dock = DockStyle.Fill;
                mainPanel.AutoScroll = true;
                mainPanel.CellBorderStyle = TableLayoutPanelCellBorderStyle.Single;

                // We'll do 1 column, as we'll place each material row with FlowLayout or something
                mainPanel.ColumnCount = 1;
                mainPanel.RowCount = materials.Count;

                for (int i = 0; i < materials.Count; i++)
                {
                    mainPanel.RowStyles.Add(new RowStyle(SizeType.AutoSize));

                    Panel rowPanel = new Panel();
                    rowPanel.Dock = DockStyle.Top;
                    rowPanel.Height = 200;
                    rowPanel.AutoScroll = true;

                    string materialName = materials[i];
                    Selections[direction][materialName] = -1; // default: no selection yet

                    // Horizontal Flow: label + candidate pictures
                    FlowLayoutPanel flow = new FlowLayoutPanel();
                    flow.Dock = DockStyle.Fill;
                    flow.AutoScroll = true;

                    // Label on the left
                    Label matLabel = new Label();
                    matLabel.Text = materialName;
                    matLabel.Font = new Font(matLabel.Font, FontStyle.Bold);
                    matLabel.Width = 120;
                    matLabel.Height = 30;
                    matLabel.TextAlign = ContentAlignment.MiddleLeft;
                    flow.Controls.Add(matLabel);

                    // The candidate bitmaps
                    var candidateBitmaps = _allCandidates[direction][materialName];

                    if (candidateBitmaps.Count == 0)
                    {
                        Label noMasksLabel = new Label();
                        noMasksLabel.Text = "No masks available";
                        noMasksLabel.Width = 160;
                        noMasksLabel.Height = 160;
                        noMasksLabel.TextAlign = ContentAlignment.MiddleCenter;
                        noMasksLabel.BorderStyle = BorderStyle.FixedSingle;
                        flow.Controls.Add(noMasksLabel);
                    }
                    else
                    {
                        // Add each candidate bitmap
                        for (int c = 0; c < candidateBitmaps.Count; c++)
                        {
                            // Create a picture box for this candidate
                            PictureBox pb = new PictureBox();
                            pb.Width = 160;
                            pb.Height = 160;
                            pb.SizeMode = PictureBoxSizeMode.Zoom;
                            pb.BorderStyle = BorderStyle.FixedSingle;
                            pb.Image = candidateBitmaps[c];
                            int localIndex = c;

                            // Set up click handler for selection
                            pb.Click += (s, e) =>
                            {
                                // On click, set selection
                                Selections[direction][materialName] = localIndex;
                                // Also store the chosen mask
                                SelectedMasks[direction][materialName] = candidateBitmaps[localIndex];
                                // Update border color to indicate selection
                                foreach (Control ctrl in flow.Controls)
                                {
                                    if (ctrl is PictureBox picBox)
                                        picBox.BackColor = Color.Transparent;
                                }
                                pb.BackColor = Color.LightBlue;
                            };

                            // Add the picture box to the flow layout
                            flow.Controls.Add(pb);
                        }
                    }

                    rowPanel.Controls.Add(flow);
                    mainPanel.Controls.Add(rowPanel, 0, i);
                }

                tab.Controls.Add(mainPanel);
                tabControl.TabPages.Add(tab);
            }
        }


        private void BtnOK_Click(object sender, EventArgs e)
        {
            // On OK, we finalize the selections
            this.DialogResult = DialogResult.OK;
            this.Close();
        }

        private void BtnPreview_Click(object sender, EventArgs e)
        {
            // Send the current "SelectedMasks" to the main viewer or SAMForm to show a preview
            if (_parentForm != null)
            {
                _parentForm.PreviewCandidatesInMainView(SelectedMasks);
            }
        }

        private void BtnSaveComposite_Click(object sender, EventArgs e)
        {
            // Saves the composite of the currently selected masks, direction by direction
            using (SaveFileDialog sfd = new SaveFileDialog())
            {
                sfd.Filter = "PNG File|*.png";
                sfd.Title = "Save Composite Image";
                if (sfd.ShowDialog() == DialogResult.OK)
                {
                    Bitmap composite = CreateCompositeImage();
                    composite.Save(sfd.FileName, ImageFormat.Png);
                    composite.Dispose();
                    MessageBox.Show("Composite saved.");
                }
            }
        }

        /// <summary>
        /// Creates one big composite image containing *all* candidate images
        /// produced by the segmenter, for all directions/materials/candidates.
        /// Rows = materials, columns = (directions * maxCandidateCount).
        /// If applyJetColormap=true, we color each pixel via the Jet colormap
        /// instead of copying raw grayscale/black/white.
        /// 
        /// If no images exist or we find zero width/height, we return a 200x200 fallback.
        /// </summary>
        private Bitmap CreateCompositeImage(bool applyJetColormap = false)
        {
            // 1) Gather all directions in _allCandidates
            //    e.g. "XY", "XZ", "YZ"
            var directions = _allCandidates.Keys.ToList();
            // Sort them if you want a stable left->right order
            directions.Sort();

            // 2) Gather all materials that appear in *any* direction
            HashSet<string> materialSet = new HashSet<string>();
            foreach (var dir in directions)
            {
                foreach (var matKv in _allCandidates[dir].Keys)
                {
                    materialSet.Add(matKv);
                }
            }
            var allMaterials = materialSet.ToList();
            // Sort them if you want alphabetical top->bottom
            allMaterials.Sort();

            // 3) Find the maximum number of candidate images among all directions/materials
            //    e.g. if most have 3, but some have 4, we use 4 as maxCandidateCount.
            int maxCandidateCount = 0;
            foreach (var dir in directions)
            {
                foreach (var mat in _allCandidates[dir].Keys)
                {
                    int count = _allCandidates[dir][mat].Count;
                    if (count > maxCandidateCount)
                        maxCandidateCount = count;
                }
            }

            // 4) Determine the largest tile width/height among all bitmaps
            //    so that every candidate can fit in an equally sized tile
            int tileW = 0;
            int tileH = 0;
            foreach (var dir in directions)
            {
                foreach (var mat in _allCandidates[dir].Keys)
                {
                    var candidateList = _allCandidates[dir][mat];
                    foreach (var bmp in candidateList)
                    {
                        if (bmp != null)
                        {
                            tileW = Math.Max(tileW, bmp.Width);
                            tileH = Math.Max(tileH, bmp.Height);
                        }
                    }
                }
            }

            // If we found no valid images or the tile dimension is 0, return a fallback
            if (tileW < 1 || tileH < 1 || allMaterials.Count == 0 || maxCandidateCount == 0)
            {
                // No valid masks => return a small fallback
                return new Bitmap(200, 200);
            }

            // 5) Compute final composite size:
            //    Each row = one material => we have allMaterials.Count rows
            //    Each row's columns = directions.Count * maxCandidateCount
            //    So total columns = directions.Count * maxCandidateCount
            int totalCols = directions.Count * maxCandidateCount;
            int finalWidth = totalCols * tileW;
            int finalHeight = allMaterials.Count * tileH;

            // If final dimension is invalid, also bail out
            if (finalWidth < 1 || finalHeight < 1)
            {
                return new Bitmap(200, 200);
            }

            Bitmap finalComposite = new Bitmap(finalWidth, finalHeight);
            using (Graphics g = Graphics.FromImage(finalComposite))
            {
                // Fill background
                g.Clear(Color.Black);
            }

            // Optionally build the Jet color table once (256 entries)
            Color[] jetTable = null;
            if (applyJetColormap)
            {
                jetTable = BuildJetLookupTable();
            }

            // 6) Now copy each candidate image into the correct "cell"
            //    Row index = material index
            //    Column index = directionIndex * maxCandidateCount + candidateIndex
            for (int row = 0; row < allMaterials.Count; row++)
            {
                string materialName = allMaterials[row];

                for (int dIdx = 0; dIdx < directions.Count; dIdx++)
                {
                    string dir = directions[dIdx];
                    // If this direction lacks that material, skip
                    if (!_allCandidates[dir].ContainsKey(materialName))
                        continue;

                    var candidateList = _allCandidates[dir][materialName];
                    for (int cIdx = 0; cIdx < candidateList.Count; cIdx++)
                    {
                        Bitmap src = candidateList[cIdx];
                        if (src == null)
                            continue;

                        // Column offset for this direction and candidate
                        int col = dIdx * maxCandidateCount + cIdx;
                        // x,y in final composite
                        int destX = col * tileW;
                        int destY = row * tileH;

                        // We'll do a pixel-by-pixel copy if applyJetColormap is true,
                        // so we can color map them. Otherwise, we can do a quick DrawImage.
                        if (!applyJetColormap)
                        {
                            // Just do a standard draw:
                            using (Graphics g2 = Graphics.FromImage(finalComposite))
                            {
                                g2.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
                                g2.DrawImage(src, destX, destY, tileW, tileH);
                            }
                        }
                        else
                        {
                            // apply Jet color map:
                            // We'll read each pixel from 'src', 
                            // map its brightness to jet color,
                            // and put it in finalComposite at [destX..destX+tileW, destY..destY+tileH].
                            for (int yy = 0; yy < src.Height; yy++)
                            {
                                for (int xx = 0; xx < src.Width; xx++)
                                {
                                    Color c = src.GetPixel(xx, yy);
                                    // assume grayscale or black/white => c.R ~ c.G ~ c.B
                                    byte intensity = c.R;

                                    // if you have black/white masks, c.R is 0 or 255 or something in-between
                                    // map to [0..255]
                                    int idx = intensity; // already 0..255
                                                         // get color from jet table
                                    Color jetColor = jetTable[idx];

                                    // Write to final composite if you want “transparent for black”:
                                    // if it's black (0?), skip. If we want always color, we do no skip
                                    if (intensity > 0)
                                    {
                                        finalComposite.SetPixel(
                                            destX + xx,
                                            destY + yy,
                                            jetColor
                                        );
                                    }
                                    else
                                    {
                                        // If you want fully black for zero-intensity:
                                        // finalComposite.SetPixel(destX+xx, destY+yy, Color.Black);
                                        // Or do nothing if you want to keep the background from a previous image
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return finalComposite;
        }

        /// <summary>
        /// Builds a 256-element Jet colormap that goes from deep blue (index=0)
        /// through cyan/green/yellow to red (index=255).
        /// This is a standard “Jet” approximation similar to MATLAB’s older colormap.
        /// </summary>
        private Color[] BuildJetLookupTable()
        {
            // We won't skip anything for brevity. We'll produce an explicit 
            // interpolation from (0 => Blue) to (0.35 => Cyan) to (0.65 => Yellow) to (1 => Red).
            // A typical formula approach is:

            Color[] table = new Color[256];

            // “Jet” can be approximated by dividing the range [0..1] into four intervals:
            //  0.00..0.35 => from Blue to Cyan,
            //  0.35..0.65 => from Cyan to Yellow,
            //  0.65..1.00 => from Yellow to Red.
            // We'll do a linear interpolation on each channel.

            for (int i = 0; i < 256; i++)
            {
                float x = i / 255f; // normalized [0..1]
                float r, g, b;
                r = g = b = 0f;

                if (x <= 0.35f)
                {
                    // Blue -> Cyan
                    // at x=0.0 => (R=0, G=0, B=1)
                    // at x=0.35 => (R=0, G=1, B=1)
                    float t = x / 0.35f;
                    r = 0f;
                    g = t;
                    b = 1f;
                }
                else if (x <= 0.65f)
                {
                    // Cyan -> Yellow
                    // at x=0.35 => (R=0, G=1, B=1)
                    // at x=0.65 => (R=1, G=1, B=0)
                    float t = (x - 0.35f) / (0.65f - 0.35f);
                    r = t;
                    g = 1f;
                    b = 1f - t;
                }
                else
                {
                    // Yellow -> Red
                    // at x=0.65 => (R=1, G=1, B=0)
                    // at x=1.0  => (R=1, G=0, B=0)
                    float t = (x - 0.65f) / (0.35f);
                    r = 1f;
                    g = 1f - t;
                    b = 0f;
                }

                // clamp r,g,b to [0..1] just in case
                r = Math.Min(1f, Math.Max(0f, r));
                g = Math.Min(1f, Math.Max(0f, g));
                b = Math.Min(1f, Math.Max(0f, b));

                byte rr = (byte)(r * 255);
                byte gg = (byte)(g * 255);
                byte bb = (byte)(b * 255);
                table[i] = Color.FromArgb(rr, gg, bb);
            }
            return table;
        }


    }
}
