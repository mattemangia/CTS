using System;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Drawing.Imaging;

namespace CTSegmenter
{
    /// <summary>
    /// Static class providing 3D segmentation propagation functionality using both SAM and SAM 2.1
    /// </summary>
    public static class SegmentationPropagator
    {
        /// <summary>
        /// Propagates segmentation in selected directions based on a starting slice
        /// </summary>
        /// <param name="mainForm">The main form with volume data</param>
        /// <param name="settings">SAM settings</param>
        /// <param name="threshold">Segmentation threshold in [0..255]</param>
        /// <param name="directions">Directions to propagate</param>
        /// <returns>The segmented volume or null if propagation failed</returns>
        public static byte[,,] Propagate(MainForm mainForm,
                                 SAMSettingsParams settings,
                                 int threshold,
                                 SAMForm.SegmentationDirection directions)
        {
            int width = mainForm.GetWidth();
            int height = mainForm.GetHeight();
            int depth = mainForm.GetDepth();

            var directionResults = new Dictionary<string, byte[,,]>();
            // Determine model paths (only SAM 2.1 is supported now)
            string modelFolder = settings.ModelFolderPath;
            string imageEncoderPath = Path.Combine(modelFolder, "sam2.1_large.encoder.onnx");
            string maskDecoderPath = Path.Combine(modelFolder, "sam2.1_large.decoder.onnx");
            // If legacy paths were set, ignore them and log
            if (!settings.UseSam2Models)
            {
                Logger.Log("[SegmentationPropagator] Legacy SAM model support is removed. Forcing SAM 2.1 usage.");
                settings.UseSam2Models = true;
            }
            // Validate SAM2.1 model files
            if (!File.Exists(imageEncoderPath) || !File.Exists(maskDecoderPath))
            {
                if (!File.Exists(imageEncoderPath)) Logger.Log($"Missing SAM2.1 encoder: {imageEncoderPath}");
                if (!File.Exists(maskDecoderPath)) Logger.Log($"Missing SAM2.1 decoder: {maskDecoderPath}");
                return null;
            }

            // Create segmenter (SAM 2.1 only)
            using (var segmenter = new CTMemorySegmenter(imageEncoderPath, maskDecoderPath))
            {
                segmenter.MaskBinarizationThreshold = threshold / 255f; // use provided threshold (0.5 default)
                segmenter.UseSelectiveHoleFilling = settings.UseSelectiveHoleFilling;

                
                // Propagate in each selected direction using SAM2.1 logic
                if (directions.HasFlag(SAMForm.SegmentationDirection.XY))
                {
                    var xyResult = PropagateSam2XYDirection(segmenter, mainForm, mainForm.GetWidth(), mainForm.GetHeight(), mainForm.GetDepth());
                    if (xyResult != null)
                    {
                        directionResults["XY"] = xyResult;
                        Logger.Log("[SegmentationPropagator] SAM2.1 XY direction propagation done.");
                    }
                }
                if (directions.HasFlag(SAMForm.SegmentationDirection.XZ))
                {
                    var xzResult = PropagateSam2XZDirection(segmenter, mainForm, mainForm.GetWidth(), mainForm.GetHeight(), mainForm.GetDepth());
                    if (xzResult != null)
                    {
                        directionResults["XZ"] = xzResult;
                        Logger.Log("[SegmentationPropagator] SAM2.1 XZ direction propagation done.");
                    }
                }
                if (directions.HasFlag(SAMForm.SegmentationDirection.YZ))
                {
                    var yzResult = PropagateSam2YZDirection(segmenter, mainForm, mainForm.GetWidth(), mainForm.GetHeight(), mainForm.GetDepth());
                    if (yzResult != null)
                    {
                        directionResults["YZ"] = yzResult;
                        Logger.Log("[SegmentationPropagator] SAM2.1 YZ direction propagation done.");
                    }
                
                }
                else
                {
                    // Original SAM
                    if (directions.HasFlag(SAMForm.SegmentationDirection.XY))
                    {
                        var xyResult = PropagateXYDirection(segmenter, mainForm, width, height, depth);
                        if (xyResult != null)
                        {
                            directionResults["XY"] = xyResult;
                            Logger.Log("[SegmentationPropagator] Original SAM XY propagation done.");
                        }
                    }
                    if (directions.HasFlag(SAMForm.SegmentationDirection.XZ))
                    {
                        var xzResult = PropagateXZDirection(segmenter, mainForm, width, height, depth);
                        if (xzResult != null)
                        {
                            directionResults["XZ"] = xzResult;
                            Logger.Log("[SegmentationPropagator] Original SAM XZ propagation done.");
                        }
                    }
                    if (directions.HasFlag(SAMForm.SegmentationDirection.YZ))
                    {
                        var yzResult = PropagateYZDirection(segmenter, mainForm, width, height, depth);
                        if (yzResult != null)
                        {
                            directionResults["YZ"] = yzResult;
                            Logger.Log("[SegmentationPropagator] Original SAM YZ propagation done.");
                        }
                    }
                }
            }

            // If multiple directions exist, we might fuse them. (Implementation omitted for brevity.)
            if (directionResults.Count == 0)
            {
                Logger.Log("[SegmentationPropagator] No directions done, returning null");
                return null;
            }
            else if (directionResults.Count == 1)
            {
                // Return single result
                return directionResults.Values.First();
            }
            else
            {
                // If you want to do e.g. majority voting across XY/XZ/YZ results, do it here.
                // We'll just return XY if present, else the first key
                if (directionResults.ContainsKey("XY")) return directionResults["XY"];
                return directionResults.Values.First();
            }
        }

        // ------------------------------------------------------------------------
        // SAM2.1 XY propagation
        // ------------------------------------------------------------------------
        private static byte[,,] PropagateSam2XYDirection(
            CTMemorySegmenter segmenter,
            MainForm mainForm,
            int width,
            int height,
            int depth)
        {
            // Create output volume
            byte[,,] result = new byte[width, height, depth];

            // Collect materials except 'Exterior'
            List<Material> materials = mainForm.Materials
                .Where(m => !m.IsExterior)
                .ToList();

            // For each Z slice in ascending order, we:
            //  - Get or build a slice annotation mask for each material
            //  - If Z==0, we rely solely on user-provided prompts
            //  - For Z>0, we feed the mask from Z-1 as 'mask_input' to guide the segmentation
            for (int z = 0; z < depth; z++)
            {
                // Grab the XY slice as a 24-bit image
                Bitmap sliceBmp = mainForm.GetSliceBitmap(z);
                // We'll accumulate all materials' masks into "resultSlice" as 0=background, materialID as foreground
                byte[,] resultSlice = new byte[width, height];

                foreach (var mat in materials)
                {
                    // Build the annotation points for this slice
                    List<AnnotationPoint> slicePoints = BuildSlicePoints(mainForm, z, mat, materials);

                    // We retrieve the *previous slice’s mask* for the same material as 'mask_input'.
                    // If z==0, there's no previous slice, so we pass an empty mask.
                    float[] prevMaskLogits = null; // shape=1x256x256 for SAM2.1
                    if (z > 0)
                    {
                        prevMaskLogits = BuildPreviousMaskLogits(result, width, height,
                                                                 sliceIndex: z - 1,
                                                                 materialID: mat.ID,
                                                                 segmenter.MaskBinarizationThreshold);
                    }

                    // Now call the new method with mask_input
                    bool[,] binMask = segmenter.ProcessXYSlice_WithMaskInput(
                        sliceBmp,
                        slicePoints,
                        mat.Name,
                        prevMaskLogits,
                        width, height);

                    // Merge into resultSlice
                    if (binMask != null)
                    {
                        for (int yy = 0; yy < height; yy++)
                        {
                            for (int xx = 0; xx < width; xx++)
                            {
                                if (binMask[yy, xx])
                                {
                                    resultSlice[xx, yy] = mat.ID;
                                }
                            }
                        }
                    }
                }

                // Copy resultSlice into the 3D array
                for (int yy = 0; yy < height; yy++)
                {
                    for (int xx = 0; xx < width; xx++)
                    {
                        result[xx, yy, z] = resultSlice[xx, yy];
                    }
                }
            }
            return result;
        }

        // Similarly for XZ and YZ:
        private static byte[,,] PropagateSam2XZDirection(
            CTMemorySegmenter segmenter,
            MainForm mainForm,
            int width,
            int height,
            int depth)
        {
            byte[,,] result = new byte[width, height, depth];
            // gather non-exterior
            var materials = mainForm.Materials
                .Where(m => !m.IsExterior)
                .ToList();

            // XZ means fix Y, vary X/Z
            // For y in [0..height-1]
            for (int y = 0; y < height; y++)
            {
                Bitmap sliceBmp = mainForm.GetXZSliceBitmap(y);
                byte[,] resultSlice = new byte[width, depth];

                foreach (var mat in materials)
                {
                    List<AnnotationPoint> slicePoints = BuildXZSlicePoints(mainForm, y, mat, materials);

                    float[] prevMaskLogits = null;
                    // If y>0, build from y-1
                    if (y > 0)
                    {
                        prevMaskLogits = BuildPreviousMaskLogits_XZ(result, width, depth,
                                                                    sliceIndexY: y - 1,
                                                                    matID: mat.ID,
                                                                    segmenter.MaskBinarizationThreshold);
                    }

                    bool[,] binMask = segmenter.ProcessXZSlice_WithMaskInput(
                        sliceBmp,
                        slicePoints,
                        mat.Name,
                        prevMaskLogits,
                        width, depth);

                    if (binMask != null)
                    {
                        for (int xx = 0; xx < width; xx++)
                        {
                            for (int zz = 0; zz < depth; zz++)
                            {
                                if (binMask[zz, xx])
                                {
                                    result[xx, y, zz] = mat.ID;
                                }
                            }
                        }
                    }
                }
            }
            return result;
        }

        private static byte[,,] PropagateSam2YZDirection(
            CTMemorySegmenter segmenter,
            MainForm mainForm,
            int width,
            int height,
            int depth)
        {
            byte[,,] result = new byte[width, height, depth];
            var materials = mainForm.Materials
                .Where(m => !m.IsExterior)
                .ToList();

            // YZ means fix X, vary Y/Z
            for (int x = 0; x < width; x++)
            {
                Bitmap sliceBmp = mainForm.GetYZSliceBitmap(x);
                byte[,] resultSlice = new byte[height, depth];

                foreach (var mat in materials)
                {
                    List<AnnotationPoint> slicePoints = BuildYZSlicePoints(mainForm, x, mat, materials);

                    float[] prevMaskLogits = null;
                    if (x > 0)
                    {
                        prevMaskLogits = BuildPreviousMaskLogits_YZ(result, height, depth,
                                                                    sliceIndexX: x - 1,
                                                                    matID: mat.ID,
                                                                    segmenter.MaskBinarizationThreshold);
                    }

                    bool[,] binMask = segmenter.ProcessYZSlice_WithMaskInput(
                        sliceBmp,
                        slicePoints,
                        mat.Name,
                        prevMaskLogits,
                        height, depth);

                    if (binMask != null)
                    {
                        for (int yy = 0; yy < height; yy++)
                        {
                            for (int zz = 0; zz < depth; zz++)
                            {
                                if (binMask[yy, zz])
                                {
                                    result[x, yy, zz] = mat.ID;
                                }
                            }
                        }
                    }
                }
            }
            return result;
        }

        // ------------------------------------------------------------------------
        // Original SAM versions (omitted for brevity)...
        // ------------------------------------------------------------------------
        private static byte[,,] PropagateXYDirection(CTMemorySegmenter seg, MainForm mf, int w, int h, int d)
        {
            // ... older approach, ignoring mask_input
            return null;
        }
        private static byte[,,] PropagateXZDirection(CTMemorySegmenter seg, MainForm mf, int w, int h, int d)
        {
            return null;
        }
        private static byte[,,] PropagateYZDirection(CTMemorySegmenter seg, MainForm mf, int w, int h, int d)
        {
            return null;
        }

        // ------------------------------------------------------------------------
        // Build annotation points for XY slices
        // We treat points from all materials for negative prompts except the current.
        // This helps a single run isolate just the target mat (like we do in CTMemorySegmenter).
        // ------------------------------------------------------------------------
        private static List<AnnotationPoint> BuildSlicePoints(
            MainForm mainForm,
            int sliceZ,
            Material targetMat,
            List<Material> allMats)
        {
            // Grab all user annotation points that lie on Z=sliceZ
            var sliceAllPts = mainForm.AnnotationMgr.Points
                .Where(p => p.Z == sliceZ)
                .ToList();

            // We want to keep them for SAM. 
            // Mark them with label=1 if p.Label == targetMat, else 0.
            // We'll do that inside CTMemorySegmenter anyway, so just pass them all here.
            // But let's ensure we keep only relevant materials (the user might have typed random).
            return sliceAllPts
                .Where(p => allMats.Any(m => m.Name.Equals(p.Label, StringComparison.OrdinalIgnoreCase)))
                .ToList();
        }

        // Similarly for XZ
        private static List<AnnotationPoint> BuildXZSlicePoints(
            MainForm mainForm,
            int sliceY,
            Material targetMat,
            List<Material> allMats)
        {
            var sliceAllPts = mainForm.AnnotationMgr.Points
                .Where(p => p.Y == sliceY)
                .ToList();
            return sliceAllPts
                .Where(p => allMats.Any(m => m.Name.Equals(p.Label, StringComparison.OrdinalIgnoreCase)))
                .ToList();
        }

        // And YZ
        private static List<AnnotationPoint> BuildYZSlicePoints(
            MainForm mainForm,
            int sliceX,
            Material targetMat,
            List<Material> allMats)
        {
            var sliceAllPts = mainForm.AnnotationMgr.Points
                .Where(p => p.X == sliceX)
                .ToList();
            return sliceAllPts
                .Where(p => allMats.Any(m => m.Name.Equals(p.Label, StringComparison.OrdinalIgnoreCase)))
                .ToList();
        }

        // ------------------------------------------------------------------------
        // Build previous slice's mask logits for mask_input
        // We'll create a float[1*1*256*256] (SAM2.1 default) where background=-10, foreground=+10
        // ------------------------------------------------------------------------
        private static float[] BuildPreviousMaskLogits(byte[,,] volume,
                                                       int w, int h,
                                                       int sliceIndex,
                                                       byte materialID,
                                                       float binThreshold)
        {
            // We'll build a 256x256 image representing the chosen material in sliceIndex
            // Then convert to logits in [-10,10].
            // If pixel = materialID => 10, else -10
            // Output shape = [1,1,256,256]
            var logits = new float[1 * 1 * 256 * 256];
            int idx = 0;

            for (int yy = 0; yy < 256; yy++)
            {
                for (int xx = 0; xx < 256; xx++)
                {
                    // Map (xx, yy) in 256 space -> (X, Y) in w,h
                    int X = (int)(xx / 255.0f * (w - 1));
                    int Y = (int)(yy / 255.0f * (h - 1));
                    byte val = volume[X, Y, sliceIndex];
                    bool isFg = (val == materialID);
                    float logit = isFg ? 10f : -10f;
                    logits[idx++] = logit;
                }
            }
            return logits;
        }

        // Similar for XZ slice
        private static float[] BuildPreviousMaskLogits_XZ(byte[,,] volume,
                                                          int w, int d,
                                                          int sliceIndexY,
                                                          byte matID,
                                                          float binThreshold)
        {
            float[] logits = new float[1 * 1 * 256 * 256];
            int idx = 0;
            for (int yy = 0; yy < 256; yy++)
            {
                for (int xx = 0; xx < 256; xx++)
                {
                    // (xx,yy) => (X,Z)
                    int X = (int)(xx / 255f * (w - 1));
                    int Z = (int)(yy / 255f * (d - 1));
                    byte val = volume[X, sliceIndexY, Z];
                    bool isFg = (val == matID);
                    logits[idx++] = isFg ? 10f : -10f;
                }
            }
            return logits;
        }

        private static float[] BuildPreviousMaskLogits_YZ(byte[,,] volume,
                                                          int h, int d,
                                                          int sliceIndexX,
                                                          byte matID,
                                                          float binThreshold)
        {
            float[] logits = new float[1 * 1 * 256 * 256];
            int idx = 0;
            for (int yy = 0; yy < 256; yy++)
            {
                for (int xx = 0; xx < 256; xx++)
                {
                    // (xx,yy) => (Z, Y)
                    int Z = (int)(xx / 255f * (d - 1));
                    int Y = (int)(yy / 255f * (h - 1));
                    byte val = volume[sliceIndexX, Y, Z];
                    bool isFg = (val == matID);
                    logits[idx++] = isFg ? 10f : -10f;
                }
            }
            return logits;
        }
    }
}
